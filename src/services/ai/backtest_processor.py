# src/services/ai/backtest_processor.py (FINAL VERSION)

import pandas as pd
import numpy as np
import logging

logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)

def load_raw_data() -> tuple[pd.DataFrame, pd.DataFrame]:
    """Loads the raw Parquet files generated by data_loader.py and standardizes date formats."""
    logger.info("Loading raw Parquet files...")
    
    try:
        df_player = pd.read_parquet("player_data_raw.parquet")
        df_team_def = pd.read_parquet("team_def_data_raw.parquet")
        
        # FIX: Ensure match_date is a clean datetime object for reliable merging
        df_player['match_date'] = pd.to_datetime(df_player['match_date']).dt.normalize()
        df_team_def['match_date'] = pd.to_datetime(df_team_def['match_date']).dt.normalize()
        
        logger.info(f"Loaded player data shape: {df_player.shape}")
        logger.info(f"Loaded team defense data shape: {df_team_def.shape}")
        return df_player, df_team_def
    except FileNotFoundError as e:
        logger.error(f"Missing input file. Did the data_loader job fail? {e}")
        exit(1)


def calculate_factors(df_player: pd.DataFrame, df_team_def: pd.DataFrame) -> pd.DataFrame:
    """
    Merges data by joining the player's HOME/AWAY status to the opposing team's defensive stats,
    and then calculates the rolling O-Factors.
    """
    logger.info("Calculating rolling opponent defensive factors (O-Factors)...")
    
    # 1. Define the defensive stats columns we need
    DEF_STATS = ['sot_conceded', 'tackles_att_3rd']
    DEF_COLS = ['team_name', 'match_date'] + DEF_STATS
    
    # 2. Merge Player Data with HOME Team's Defense Stats
    # Merge Key: ['home_team', 'match_date'] -> gives us the AWAY team's stats
    logger.info("Merging with Home Team's defensive stats...")
    df_merged = pd.merge(
        df_player,
        df_team_def[DEF_COLS].rename(columns={'team_name': 'home_team'}),
        on=['home_team', 'match_date'],
        how='left',
        suffixes=('_player', '_opp_away_raw')
    )

    # 3. Merge Player Data with AWAY Team's Defense Stats
    # Merge Key: ['away_team', 'match_date'] -> gives us the HOME team's stats
    logger.info("Merging with Away Team's defensive stats...")
    df_merged = pd.merge(
        df_merged,
        df_team_def[DEF_COLS].rename(columns={'team_name': 'away_team'}),
        on=['away_team', 'match_date'],
        how='left',
        suffixes=('_temp', '_opp_home_raw')
    )

    # 4. Consolidate Opponent Factors into single columns
    logger.info("Consolidating final opponent metrics...")
    
    # Determine the opponent's stats based on the player's team side
    for stat in DEF_STATS:
        home_col = f'{stat}_opp_home_raw'
        away_col = f'{stat}_opp_away_raw'
        final_col = f'{stat}_opp_raw' # New base raw column name

        conditions = [
            (df_merged['team_side'] == 'home'), # If player was home, use away team's stats (opp_away_raw)
            (df_merged['team_side'] == 'away')  # If player was away, use home team's stats (opp_home_raw)
        ]
        
        choices = [
            df_merged[away_col], # Use stats for the team playing AWAY
            df_merged[home_col]  # Use stats for the team playing HOME
        ]
        
        # Use np.select to pick the correct opponent statistic
        df_merged[final_col] = np.select(conditions, choices, default=np.nan)
    
    # 5. Determine the opponent's name (for the final output and P-Factor calculations later)
    df_merged['opponent'] = np.where(
        df_merged['team_side'] == 'home', 
        df_merged['away_team'], 
        df_merged['home_team']
    )
    
    # 6. Calculate Rolling Average of Opponent Stats (O-Factors)
    logger.info("Calculating rolling averages (MA5)...")
    for stat in DEF_STATS:
        raw_col = f'{stat}_opp_raw'
        ma_col = f'{stat}_MA5'
        
        df_merged[ma_col] = (
            df_merged
            .groupby('opponent')[raw_col]
            # closed='left' ensures the window excludes the current row's data (no data leakage)
            .transform(lambda x: x.rolling(window=5, min_periods=1, closed='left').mean())
        )
    
    # 7. Final Cleanup
    # Drop all temporary raw columns and the home/away team columns now that we have the opponent name
    cols_to_drop = [
        col for col in df_merged.columns 
        if col.endswith('_opp_home_raw') or col.endswith('_opp_away_raw') or col.endswith('_opp_raw')
    ]
    df_merged = df_merged.drop(columns=cols_to_drop + ['home_team', 'away_team'])
    
    logger.info("O-Factors calculated and ready for the final backtesting step.")
    return df_merged


if __name__ == '__main__':
    df_player_raw, df_team_def_raw = load_raw_data()
    
    if df_player_raw.empty or df_team_def_raw.empty:
        logger.error("Cannot proceed with processing: Raw data is empty.")
        exit(1)
    
    # Step 1: Merge Data and Calculate Rolling Opponent Factors
    # Note: We now combine opponent determination and factor calculation into one step
    df_final_features = calculate_factors(df_player_raw, df_team_def_raw)
    
    # Step 2: Save the final feature set
    output_file = "final_feature_set.parquet"
    df_final_features.to_parquet(output_file, index=False)
    logger.info(f"Process complete. Final feature set saved to {output_file} with shape: {df_final_features.shape}")

