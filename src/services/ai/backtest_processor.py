# src/services/ai/backtest_processor.py

import pandas as pd
import numpy as np
import logging

logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger(__name__)

def load_raw_data() -> tuple[pd.DataFrame, pd.DataFrame]:
    """Loads the raw Parquet files generated by data_loader.py and standardizes date formats."""
    logger.info("Loading raw Parquet files...")
    
    try:
        df_player = pd.read_parquet("player_data_raw.parquet")
        df_team_def = pd.read_parquet("team_def_data_raw.parquet")
        
        # FIX: Ensure match_date is a clean datetime object for reliable merging
        df_player['match_date'] = pd.to_datetime(df_player['match_date']).dt.normalize()
        df_team_def['match_date'] = pd.to_datetime(df_team_def['match_date']).dt.normalize()
        
        logger.info(f"Loaded player data shape: {df_player.shape}")
        logger.info(f"Loaded team defense data shape: {df_team_def.shape}")
        return df_player, df_team_def
    except FileNotFoundError as e:
        logger.error(f"Missing input file. Did the data_loader job fail? {e}")
        exit(1)


def calculate_factors(df_player: pd.DataFrame, df_team_def: pd.DataFrame) -> pd.DataFrame:
    """
    Merges data by joining the player's HOME/AWAY status to the opposing team's defensive stats,
    and then calculates the rolling O-Factors.
    """
    logger.info("Calculating rolling opponent defensive factors (O-Factors)...")
    
    # 1. Define the defensive stats columns we need
    DEF_STATS = ['sot_conceded', 'tackles_att_3rd']
    DEF_COLS = ['team_name', 'match_date'] + DEF_STATS
    
    # --- Prepare Defense DataFrames with explicit final column names ---
    
    # Defense stats for the AWAY team (when player is home)
    df_opp_away = df_team_def[DEF_COLS].copy()
    df_opp_away.rename(
        columns={
            'team_name': 'away_team', # Merge key
            'sot_conceded': 'sot_conceded_opp_away_raw', # Final column name
            'tackles_att_3rd': 'tackles_att_3rd_opp_away_raw' # Final column name
        }, 
        inplace=True
    )
    
    # Defense stats for the HOME team (when player is away)
    df_opp_home = df_team_def[DEF_COLS].copy()
    df_opp_home.rename(
        columns={
            'team_name': 'home_team', # Merge key
            'sot_conceded': 'sot_conceded_opp_home_raw', # Final column name
            'tackles_att_3rd': 'tackles_att_3rd_opp_home_raw' # Final column name
        }, 
        inplace=True
    )
    
    # 2. Merge Player Data with the renamed Defense Stats (Opponent-is-Away)
    logger.info("Merging with Away Team's defensive stats (Opponent-is-Away)...")
    df_merged = pd.merge(
        df_player,
        df_opp_away, # Already renamed
        on=['away_team', 'match_date'],
        how='left'
    )

    # 3. Merge Player Data with the renamed Defense Stats (Opponent-is-Home)
    logger.info("Merging with Home Team's defensive stats (Opponent-is-Home)...")
    df_merged = pd.merge(
        df_merged,
        df_opp_home, # Already renamed
        on=['home_team', 'match_date'],
        how='left'
        # No suffixes needed here because we renamed columns beforehand
    )

    # 4. Consolidate Opponent Factors into single columns
    logger.info("Consolidating final opponent metrics...")
    
    # Determine the opponent's stats based on the player's team side
    for stat in DEF_STATS:
        # These columns must now exist due to the explicit renaming above
        away_col = f'{stat}_opp_away_raw'
        home_col = f'{stat}_opp_home_raw'
        final_col = f'{stat}_opp_raw' # New base raw column name

        conditions = [
            # If player was HOME, the opponent was AWAY. Use AWAY team's stats.
            (df_merged['team_side'] == 'home'), 
            # If player was AWAY, the opponent was HOME. Use HOME team's stats.
            (df_merged['team_side'] == 'away') 
        ]
        
        choices = [
            df_merged[away_col], 
            df_merged[home_col] 
        ]
        
        df_merged[final_col] = np.select(conditions, choices, default=np.nan)
    
    # 5. Determine the opponent's name (for the final output and P-Factor calculations later)
    df_merged['opponent'] = np.where(
        df_merged['team_side'] == 'home', 
        df_merged['away_team'], 
        df_merged['home_team']
    )
    
    # 6. Calculate Rolling Average of Opponent Stats (O-Factors)
    logger.info("Calculating rolling averages (MA5)...")
    for stat in DEF_STATS:
        raw_col = f'{stat}_opp_raw'
        ma_col = f'{stat}_MA5'
        
        df_merged[ma_col] = (
            df_merged
            .groupby('opponent')[raw_col]
            .transform(lambda x: x.rolling(window=5, min_periods=1, closed='left').mean())
        )
    
    # 7. Final Cleanup
    cols_to_drop = [
        col for col in df_merged.columns 
        if col.endswith('_opp_home_raw') or col.endswith('_opp_away_raw') or col.endswith('_opp_raw')
    ]
    # Keep 'opponent' as it's needed for the final DataFrame
    df_merged = df_merged.drop(columns=cols_to_drop + ['home_team', 'away_team'])
    
    logger.info("O-Factors calculated and ready for the final backtesting step.")
    return df_merged


if __name__ == '__main__':
    df_player_raw, df_team_def_raw = load_raw_data()
    
    if df_player_raw.empty or df_team_def_raw.empty:
        logger.error("Cannot proceed with processing: Raw data is empty.")
        exit(1)
    
    df_final_features = calculate_factors(df_player_raw, df_team_def_raw)
    
    output_file = "final_feature_set.parquet"
    df_final_features.to_parquet(output_file, index=False)
    logger.info(f"Process complete. Final feature set saved to {output_file} with shape: {df_final_features.shape}")
